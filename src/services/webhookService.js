// src/services/webhookService.js
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Webhook Auto-Sync Service
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Features:
//   â€¢ Validates GitHub webhook HMAC-SHA256 signatures
//   â€¢ Only re-runs docs on push to default branch (main/master)
//   â€¢ Generates .github/workflows/document.yml for self-hosted sync
//   â€¢ Smart diff check: skip if only non-code files changed
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

import crypto from "crypto";
import { orchestrate } from "./orchestrator.js";

// â”€â”€ Signature validation â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
export function validateWebhookSignature(payload, signature, secret) {
  if (!secret) {
    console.warn("âš ï¸WEBHOOK_SECRET not set â€” signature validation skipped");
    return true;
  }
  const expected = `sha256=${crypto
    .createHmac("sha256", secret)
    .update(payload)
    .digest("hex")}`;
  try {
    return crypto.timingSafeEqual(Buffer.from(signature), Buffer.from(expected));
  } catch {
    return false;
  }
}

// â”€â”€ Determine if push warrants re-documentation â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
export function shouldReDociument(pushPayload) {
  const { ref, repository, commits = [] } = pushPayload;

  // Only trigger on default branch
  const defaultBranch = repository?.default_branch || "main";
  if (!ref?.endsWith(defaultBranch)) {
    console.log(`   â†³ Push to ${ref} â€” not default branch, skipping`);
    return { should: false, reason: "not_default_branch" };
  }

  // Check if any meaningful code files changed
  const CODE_FILE = /\.(js|ts|jsx|tsx|py|go|rs|java|rb|php|cs|cpp|c|h|vue|svelte|prisma|graphql|sql)$/i;
  const changedFiles = commits.flatMap((c) => [
    ...(c.added    || []),
    ...(c.modified || []),
    ...(c.removed  || []),
  ]);

  const codeChanges = changedFiles.filter((f) => CODE_FILE.test(f));
  if (codeChanges.length === 0) {
    console.log("   â†³ No code files changed â€” skipping re-documentation");
    return { should: false, reason: "no_code_changes" };
  }

  return {
    should      : true,
    reason      : "code_changed",
    changedFiles: codeChanges.slice(0, 10),
    repoUrl     : repository?.html_url,
    pusher      : pushPayload.pusher?.name,
    branch      : defaultBranch,
  };
}

// â”€â”€ Handle incoming webhook â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
export async function handleWebhook({ payload, signature, secret, jobs, streams }) {
  // Validate signature
  const rawPayload = typeof payload === "string" ? payload : JSON.stringify(payload);
  if (!validateWebhookSignature(rawPayload, signature, secret)) {
    return { status: 401, body: { error: "Invalid webhook signature" } };
  }

  const parsed = typeof payload === "string" ? JSON.parse(payload) : payload;

  // Only handle push events
  const check = shouldReDociument(parsed);
  if (!check.should) {
    return { status: 200, body: { message: `Skipped: ${check.reason}` } };
  }

  console.log(`ðŸ”„ Webhook triggered re-doc for ${check.repoUrl} by ${check.pusher}`);

  // Trigger orchestration (same as manual submit)
  const jobId = crypto.randomUUID();
  jobs.set(jobId, { status: "running", events: [], result: null, triggeredBy: "webhook" });
  streams.set(jobId, []);

  orchestrate(check.repoUrl, (event) => {
    const job = jobs.get(jobId);
    if (job) job.events.push(event);
  }).then((result) => {
    const job = jobs.get(jobId);
    if (job) { job.status = result.success ? "done" : "error"; job.result = result; }
  });

  return {
    status: 202,
    body  : { message: "Re-documentation triggered", jobId, repoUrl: check.repoUrl },
  };
}

// â”€â”€ Generate GitHub Actions workflow file â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
export function generateGitHubActionsWorkflow(apiBaseUrl) {
  const base = apiBaseUrl || "https://your-documentor-instance.com";

  // GH_EXPR wraps GitHub Actions expressions so JS doesn't treat them as template literals
  const e = (expr) => "${{ " + expr + " }}";

  return [
    "# .github/workflows/document.yml",
    "# Auto-generated by Project Documentor",
    "# Regenerates documentation on every push to main",
    "",
    "name: Auto-Document",
    "",
    "on:",
    "  push:",
    "    branches: [ main, master ]",
    "    paths:",
    "      - '**.js'",
    "      - '**.ts'",
    "      - '**.py'",
    "      - '**.go'",
    "      - '**.rs'",
    "      - '**.java'",
    "      - '**.prisma'",
    "      - '**.graphql'",
    "  workflow_dispatch:",
    "",
    "jobs:",
    "  document:",
    "    name: Generate Documentation",
    "    runs-on: ubuntu-latest",
    "    timeout-minutes: 15",
    "",
    "    steps:",
    "      - name: Trigger Documentation Generation",
    "        id: trigger",
    "        env:",
    `          API_BASE_URL: ${base}`,
    "        run: |",
    `          REPO_URL="${e("github.server_url")}/${e("github.repository")}"`,
    `          RESPONSE=$(curl -s -X POST \\`,
    `            -H "Content-Type: application/json" \\`,
    `            -d "{\\"repoUrl\\": \\"$REPO_URL\\"}" \\`,
    `            "$API_BASE_URL/api/document")`,
    `          JOB_ID=$(echo "$RESPONSE" | jq -r '.jobId')`,
    `          echo "job_id=$JOB_ID" >> $GITHUB_OUTPUT`,
    `          echo "Triggered job: $JOB_ID"`,
    "",
    "      - name: Wait for completion",
    "        env:",
    `          API_BASE_URL: ${base}`,
    `          JOB_ID: ${e("steps.trigger.outputs.job_id")}`,
    "        run: |",
    "          MAX_WAIT=600",
    "          ELAPSED=0",
    "          while [ $ELAPSED -lt $MAX_WAIT ]; do",
    `            STATUS=$(curl -s "$API_BASE_URL/api/document/$JOB_ID" | jq -r '.status')`,
    `            echo "Status: $STATUS (${"{ELAPSED}"}s elapsed)"`,
    `            if [ "$STATUS" = "done" ]; then`,
    `              echo "Documentation generated successfully"`,
    "              exit 0",
    `            elif [ "$STATUS" = "error" ]; then`,
    `              echo "Documentation generation failed"`,
    "              exit 1",
    "            fi",
    "            sleep 15",
    "            ELAPSED=$((ELAPSED + 15))",
    "          done",
    `          echo "Timeout waiting for documentation"`,
    "          exit 1",
  ].join("\n");
}