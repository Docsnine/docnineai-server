// ==============================================================
// Export Service â€” PDF & Notion
//
// IMPORTANT: pdfkit and @notionhq/client are loaded with dynamic
// import() inside each function, not at the top of the file.
//
// Top-level imports would crash the entire module at load time if
// either package is missing, silently breaking all exports.
// Dynamic imports fail per-call with a clear error message instead.
// ==============================================================

// â”€â”€ PDF Export â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Streams a multi-section PDF directly to an Express response.
export async function exportToPDF(res, { meta, output, stats, securityScore }) {
  // Dynamic import â€” throws a clear error if pdfkit is not installed
  let PDFDocument;
  try {
    ({ default: PDFDocument } = await import("pdfkit"));
  } catch (e) {
    throw new Error("PDF export requires pdfkit. Run: npm install pdfkit");
  }

  const doc = new PDFDocument({ margin: 50, size: "A4" });

  res.setHeader("Content-Type", "application/pdf");
  res.setHeader(
    "Content-Disposition",
    `attachment; filename="${meta.name || "docs"}-documentation.pdf"`,
  );
  doc.pipe(res);

  const PAGE_W = doc.page.width - 100;
  const BLUE = "#2563EB";
  const DARK = "#1E293B";
  const MUTED = "#64748B";
  const RED = "#DC2626";
  const GREEN = "#16A34A";

  // â”€â”€ Cover page â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  doc.rect(0, 0, doc.page.width, 180).fill(BLUE);
  doc
    .fill("#ffffff")
    .fontSize(28)
    .font("Helvetica-Bold")
    .text(meta.name || "Project Documentation", 50, 60, { width: PAGE_W });
  doc
    .fontSize(13)
    .font("Helvetica")
    .text(meta.description || "", 50, 105, { width: PAGE_W });
  doc
    .fill(DARK)
    .fontSize(11)
    .font("Helvetica")
    .text(
      `Generated by Project Documentor  â€¢  ${new Date().toLocaleDateString()}`,
      50,
      155,
    );

  doc.moveDown(3);
  const statItems = [
    ["Files", stats?.filesAnalysed ?? 0],
    ["Endpoints", stats?.endpoints ?? 0],
    ["Models", stats?.models ?? 0],
    ["Security", `${securityScore ?? "N/A"}/100`],
  ];
  let sx = 50;
  statItems.forEach(([label, val]) => {
    doc
      .fill(BLUE)
      .fontSize(20)
      .font("Helvetica-Bold")
      .text(String(val), sx, doc.y, { width: 110, align: "center" });
    doc
      .fill(MUTED)
      .fontSize(9)
      .font("Helvetica")
      .text(label, sx, doc.y, { width: 110, align: "center" });
    sx += 120;
  });

  // â”€â”€ Helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const heading1 = (text) => {
    doc.addPage();
    doc.rect(0, 0, doc.page.width, 6).fill(BLUE);
    doc
      .moveDown(0.5)
      .fill(DARK)
      .fontSize(20)
      .font("Helvetica-Bold")
      .text(text, 50);
    doc.fill(MUTED).moveTo(50, doc.y).lineTo(550, doc.y).stroke().moveDown(0.5);
  };

  const heading2 = (text) => {
    doc
      .moveDown(0.5)
      .fill(BLUE)
      .fontSize(13)
      .font("Helvetica-Bold")
      .text(text, 50);
    doc.fill(DARK);
  };

  const body = (text) => {
    if (!text) return;
    doc
      .fill(DARK)
      .fontSize(10)
      .font("Helvetica")
      .text(stripMarkdown(text), 50, doc.y, { width: PAGE_W, align: "left" });
    doc.moveDown(0.3);
  };

  // â”€â”€ Sections â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (output.readme) {
    heading1("ðŸ“‹ README");
    body(output.readme.slice(0, 3000));
  }

  if (
    output.apiReference &&
    output.apiReference !== "No API endpoints detected."
  ) {
    heading1("ðŸŒ API Reference");
    const lines = output.apiReference.split("\n");
    for (const line of lines.slice(0, 150)) {
      if (line.startsWith("### "))
        heading2(line.replace(/^###\s*/, "").replace(/`/g, ""));
      else if (line.startsWith("| "))
        doc
          .fill(DARK)
          .fontSize(8)
          .font("Courier")
          .text(line, 50, doc.y, { width: PAGE_W });
      else body(line);
    }
  }

  if (output.schemaDocs && output.schemaDocs !== "No data models detected.") {
    heading1("ðŸ—„ï¸ Data Models");
    body(output.schemaDocs.slice(0, 2500));
  }

  if (output.securityReport) {
    heading1("ðŸ”’ Security Report");
    const scoreColor =
      (securityScore ?? 0) >= 75
        ? GREEN
        : (securityScore ?? 0) >= 50
          ? "#D97706"
          : RED;
    doc
      .fill(scoreColor)
      .fontSize(36)
      .font("Helvetica-Bold")
      .text(`${securityScore ?? "?"}/100`, 50, doc.y, {
        width: PAGE_W,
        align: "center",
      });
    doc.fill(DARK).moveDown(0.5);
    body(output.securityReport.slice(0, 2500));
  }

  if (output.internalDocs) {
    heading1("ðŸ—ï¸ Architecture & Internal Docs");
    body(output.internalDocs.slice(0, 2500));
  }

  doc.end();
}

// â”€â”€ Notion Export â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
export async function exportToNotion({ output, meta, stats, securityScore }) {
  // Dynamic import â€” throws a clear error if @notionhq/client is not installed
  let NotionClient;
  try {
    ({ Client: NotionClient } = await import("@notionhq/client"));
  } catch {
    throw new Error(
      "Notion export requires @notionhq/client. Run: npm install @notionhq/client",
    );
  }

  if (!process.env.NOTION_API_KEY || !process.env.NOTION_PARENT_PAGE_ID) {
    throw new Error(
      "NOTION_API_KEY and NOTION_PARENT_PAGE_ID must be set in .env",
    );
  }

  const notion = new NotionClient({ auth: process.env.NOTION_API_KEY });
  const parentId = process.env.NOTION_PARENT_PAGE_ID;

  const mainPage = await notion.pages.create({
    parent: { page_id: parentId },
    properties: {
      title: {
        title: [
          { text: { content: `ðŸ“„ ${meta.name || "Project"} â€” Documentation` } },
        ],
      },
    },
    children: [
      notionHeading(`Generated: ${new Date().toLocaleString()}`, 2),
      notionParagraph(meta.description || ""),
      notionDivider(),
      notionHeading("ðŸ“Š Stats", 2),
      notionParagraph(
        `Files: ${stats?.filesAnalysed} | Endpoints: ${stats?.endpoints} | Models: ${stats?.models} | Security Score: ${securityScore}/100`,
      ),
    ],
  });

  const sections = [
    { title: "ðŸ“‹ README", content: output.readme },
    { title: "ðŸŒ API Reference", content: output.apiReference },
    { title: "ðŸ—„ï¸ Data Models", content: output.schemaDocs },
    { title: "ðŸ”’ Security Report", content: output.securityReport },
    { title: "ðŸ—ï¸ Architecture", content: output.internalDocs },
  ].filter((s) => s.content && s.content.length > 10);

  const childPages = [];
  for (const section of sections) {
    const page = await notion.pages.create({
      parent: { page_id: mainPage.id },
      properties: {
        title: { title: [{ text: { content: section.title } }] },
      },
      children: markdownToNotionBlocks(section.content),
    });
    childPages.push({ title: section.title, url: page.url, id: page.id });
  }

  return { mainPageUrl: mainPage.url, mainPageId: mainPage.id, childPages };
}

// â”€â”€ Notion block builders â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function notionHeading(text, level = 1) {
  const type = `heading_${level}`;
  return {
    object: "block",
    type,
    [type]: { rich_text: [{ text: { content: text } }] },
  };
}
function notionParagraph(text) {
  return {
    object: "block",
    type: "paragraph",
    paragraph: {
      rich_text: [{ text: { content: (text || "").slice(0, 2000) } }],
    },
  };
}
function notionDivider() {
  return { object: "block", type: "divider", divider: {} };
}
function notionCode(text) {
  return {
    object: "block",
    type: "code",
    code: {
      rich_text: [{ text: { content: text.slice(0, 2000) } }],
      language: "markdown",
    },
  };
}

function markdownToNotionBlocks(markdown) {
  const blocks = [];
  const lines = (markdown || "").split("\n").slice(0, 100);
  let codeBlock = null;

  for (const line of lines) {
    if (line.startsWith("```")) {
      if (codeBlock !== null) {
        blocks.push(notionCode(codeBlock));
        codeBlock = null;
      } else {
        codeBlock = "";
      }
      continue;
    }
    if (codeBlock !== null) {
      codeBlock += line + "\n";
      continue;
    }

    if (line.startsWith("# ")) blocks.push(notionHeading(line.slice(2), 1));
    else if (line.startsWith("## "))
      blocks.push(notionHeading(line.slice(3), 2));
    else if (line.startsWith("### "))
      blocks.push(notionHeading(line.slice(4), 3));
    else if (line.startsWith("---")) blocks.push(notionDivider());
    else if (line.trim()) blocks.push(notionParagraph(line));
  }
  return blocks.slice(0, 100);
}

// â”€â”€ Strip markdown for PDF plain text â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function stripMarkdown(text) {
  return (text || "")
    .replace(/#{1,6}\s/g, "")
    .replace(/\*\*(.+?)\*\*/g, "$1")
    .replace(/\*(.+?)\*/g, "$1")
    .replace(/`(.+?)`/g, "$1")
    .replace(/```[\s\S]*?```/g, "[code block]")
    .replace(/\|.*\|/g, "")
    .replace(/^[-*]\s/gm, "â€¢ ")
    .replace(/^\d+\.\s/gm, "")
    .replace(/\[([^\]]+)\]\([^)]+\)/g, "$1")
    .replace(/\n{3,}/g, "\n\n")
    .trim();
}
