// ===================================================================
// Export Service â€” PDF & Notion
// ===================================================================

import PDFDocument from "pdfkit";
import { Client as NotionClient } from "@notionhq/client";

// â”€â”€ PDF Export â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Streams a multi-section PDF directly to an Express response
export function exportToPDF(res, { meta, output, stats, securityScore }) {
  const doc = new PDFDocument({ margin: 50, size: "A4" });

  // Pipe to HTTP response
  res.setHeader("Content-Type", "application/pdf");
  res.setHeader(
    "Content-Disposition",
    `attachment; filename="${meta.name || "docs"}-documentation.pdf"`,
  );
  doc.pipe(res);

  const PAGE_W = doc.page.width - 100; // usable width
  const BLUE = "#2563EB";
  const DARK = "#1E293B";
  const MUTED = "#64748B";
  const RED = "#DC2626";
  const GREEN = "#16A34A";

  // â”€â”€ Cover page â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  doc.rect(0, 0, doc.page.width, 180).fill(BLUE);
  doc
    .fill("#ffffff")
    .fontSize(28)
    .font("Helvetica-Bold")
    .text(meta.name || "Project Documentation", 50, 60, { width: PAGE_W });
  doc
    .fontSize(13)
    .font("Helvetica")
    .text(meta.description || "", 50, 105, { width: PAGE_W });
  doc
    .fill(DARK)
    .fontSize(11)
    .font("Helvetica")
    .text(
      `Generated by Project Documentor  â€¢  ${new Date().toLocaleDateString()}`,
      50,
      155,
    );

  // Stats bar
  doc.moveDown(3);
  const statItems = [
    ["Files", stats?.filesAnalysed || 0],
    ["Endpoints", stats?.endpoints || 0],
    ["Models", stats?.models || 0],
    ["Security", `${securityScore ?? "N/A"}/100`],
  ];
  let sx = 50;
  statItems.forEach(([label, val]) => {
    doc
      .fill(BLUE)
      .fontSize(20)
      .font("Helvetica-Bold")
      .text(String(val), sx, doc.y, { width: 110, align: "center" });
    doc
      .fill(MUTED)
      .fontSize(9)
      .font("Helvetica")
      .text(label, sx, doc.y, { width: 110, align: "center" });
    sx += 120;
  });

  // â”€â”€ Helper functions â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const heading1 = (text) => {
    doc.addPage();
    doc.rect(0, 0, doc.page.width, 6).fill(BLUE);
    doc
      .moveDown(0.5)
      .fill(DARK)
      .fontSize(20)
      .font("Helvetica-Bold")
      .text(text, 50);
    doc.fill(MUTED).moveTo(50, doc.y).lineTo(550, doc.y).stroke().moveDown(0.5);
  };

  const heading2 = (text) => {
    doc
      .moveDown(0.5)
      .fill(BLUE)
      .fontSize(13)
      .font("Helvetica-Bold")
      .text(text, 50);
    doc.fill(DARK);
  };

  const body = (text) => {
    if (!text) return;
    doc
      .fill(DARK)
      .fontSize(10)
      .font("Helvetica")
      .text(stripMarkdown(text), 50, doc.y, { width: PAGE_W, align: "left" });
    doc.moveDown(0.3);
  };

  const codeBlock = (text) => {
    if (!text) return;
    const safe = text.slice(0, 300);
    doc
      .rect(50, doc.y, PAGE_W, 12 + safe.split("\n").length * 11)
      .fill("#F1F5F9");
    doc
      .fill("#0F172A")
      .fontSize(8)
      .font("Courier")
      .text(safe, 58, doc.y + 4, { width: PAGE_W - 16 });
    doc.fill(DARK).moveDown(0.5);
  };

  // â”€â”€ Section: README â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (output.readme) {
    heading1("ðŸ“‹ README");
    body(output.readme.slice(0, 3000));
  }

  // â”€â”€ Section: API Reference â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (
    output.apiReference &&
    output.apiReference !== "No API endpoints detected."
  ) {
    heading1("ðŸŒ API Reference");
    const lines = output.apiReference.split("\n");
    for (const line of lines.slice(0, 150)) {
      if (line.startsWith("### ")) {
        heading2(line.replace(/^###\s*/, "").replace(/`/g, ""));
      } else if (line.startsWith("| ")) {
        doc
          .fill(DARK)
          .fontSize(8)
          .font("Courier")
          .text(line, 50, doc.y, { width: PAGE_W });
      } else {
        body(line);
      }
    }
  }

  // â”€â”€ Section: Data Models â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (output.schemaDocs && output.schemaDocs !== "No data models detected.") {
    heading1("ðŸ—„ï¸ Data Models");
    body(output.schemaDocs.slice(0, 2500));
  }

  // â”€â”€ Section: Security Report â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (output.securityReport) {
    heading1("ðŸ”’ Security Report");
    const scoreColor =
      (securityScore || 0) >= 75
        ? GREEN
        : (securityScore || 0) >= 50
          ? "#D97706"
          : RED;
    doc
      .fill(scoreColor)
      .fontSize(36)
      .font("Helvetica-Bold")
      .text(`${securityScore ?? "?"}/100`, 50, doc.y, {
        width: PAGE_W,
        align: "center",
      });
    doc.fill(DARK).moveDown(0.5);
    body(output.securityReport.slice(0, 2500));
  }

  // â”€â”€ Section: Architecture â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (output.internalDocs) {
    heading1("ðŸ—ï¸ Architecture & Internal Docs");
    body(output.internalDocs.slice(0, 2500));
  }

  doc.end();
}

// â”€â”€ Notion Export â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
export async function exportToNotion({ output, meta, stats, securityScore }) {
  if (!process.env.NOTION_API_KEY || !process.env.NOTION_PARENT_PAGE_ID) {
    throw new Error(
      "NOTION_API_KEY and NOTION_PARENT_PAGE_ID must be set in .env",
    );
  }

  const notion = new NotionClient({ auth: process.env.NOTION_API_KEY });
  const parentId = process.env.NOTION_PARENT_PAGE_ID;

  // Create parent documentation page
  const mainPage = await notion.pages.create({
    parent: { page_id: parentId },
    properties: {
      title: {
        title: [
          { text: { content: `ðŸ“„ ${meta.name || "Project"} â€” Documentation` } },
        ],
      },
    },
    children: [
      notionHeading(`Generated: ${new Date().toLocaleString()}`, 2),
      notionParagraph(`${meta.description || ""}`),
      notionDivider(),
      notionHeading("ðŸ“Š Stats", 2),
      notionParagraph(
        `Files: ${stats?.filesAnalysed} | Endpoints: ${stats?.endpoints} | Models: ${stats?.models} | Security Score: ${securityScore}/100`,
      ),
    ],
  });

  // Create child pages for each section
  const sections = [
    { title: "ðŸ“‹ README", content: output.readme },
    { title: "ðŸŒ API Reference", content: output.apiReference },
    { title: "ðŸ—„ï¸ Data Models", content: output.schemaDocs },
    { title: "ðŸ”’ Security Report", content: output.securityReport },
    { title: "ðŸ—ï¸ Architecture", content: output.internalDocs },
  ].filter((s) => s.content && s.content.length > 10);

  const childPages = [];
  for (const section of sections) {
    const page = await notion.pages.create({
      parent: { page_id: mainPage.id },
      properties: {
        title: { title: [{ text: { content: section.title } }] },
      },
      children: markdownToNotionBlocks(section.content),
    });
    childPages.push({ title: section.title, url: page.url, id: page.id });
  }

  return { mainPageUrl: mainPage.url, mainPageId: mainPage.id, childPages };
}

// â”€â”€ Notion block builders â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function notionHeading(text, level = 1) {
  const type = `heading_${level}`;
  return {
    object: "block",
    type,
    [type]: { rich_text: [{ text: { content: text } }] },
  };
}
function notionParagraph(text) {
  return {
    object: "block",
    type: "paragraph",
    paragraph: { rich_text: [{ text: { content: text.slice(0, 2000) } }] },
  };
}
function notionDivider() {
  return { object: "block", type: "divider", divider: {} };
}
function notionCode(text) {
  return {
    object: "block",
    type: "code",
    code: {
      rich_text: [{ text: { content: text.slice(0, 2000) } }],
      language: "markdown",
    },
  };
}

// Convert markdown sections â†’ Notion blocks (simplified)
function markdownToNotionBlocks(markdown) {
  const blocks = [];
  const lines = markdown.split("\n").slice(0, 100); // Notion has block limits
  let codeBlock = null;

  for (const line of lines) {
    if (line.startsWith("```")) {
      if (codeBlock !== null) {
        blocks.push(notionCode(codeBlock));
        codeBlock = null;
      } else {
        codeBlock = "";
      }
      continue;
    }
    if (codeBlock !== null) {
      codeBlock += line + "\n";
      continue;
    }

    if (line.startsWith("# ")) {
      blocks.push(notionHeading(line.slice(2), 1));
      continue;
    }
    if (line.startsWith("## ")) {
      blocks.push(notionHeading(line.slice(3), 2));
      continue;
    }
    if (line.startsWith("### ")) {
      blocks.push(notionHeading(line.slice(4), 3));
      continue;
    }
    if (line.startsWith("---")) {
      blocks.push(notionDivider());
      continue;
    }
    if (line.trim()) blocks.push(notionParagraph(line));
  }
  return blocks.slice(0, 100); // Notion API limit per request
}

// â”€â”€ Strip markdown for PDF plain text â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function stripMarkdown(text) {
  return text
    .replace(/#{1,6}\s/g, "")
    .replace(/\*\*(.+?)\*\*/g, "$1")
    .replace(/\*(.+?)\*/g, "$1")
    .replace(/`(.+?)`/g, "$1")
    .replace(/```[\s\S]*?```/g, "[code block]")
    .replace(/\|.*\|/g, "")
    .replace(/^[-*]\s/gm, "â€¢ ")
    .replace(/^\d+\.\s/gm, "")
    .replace(/\[([^\]]+)\]\([^)]+\)/g, "$1")
    .replace(/\n{3,}/g, "\n\n")
    .trim();
}
